# Roadmap

Цели развития API Rate Limiter (FastAPI + Redis)

Короткая перспектива (1–2 недели)
- Обязательный Redis-бэкенд в проде: проверка подключения, авто‑фолбэк только в dev.
- Стратегии лимитов: добавить sliding window и token bucket в дополнение к fixed window.
- Конфигурация: вынести лимиты/окна/namespace в env через pydantic‑settings.
- Пер‑роут декларативные лимиты: удобный хелпер/декоратор и единый формат ошибок.
- Заголовки ответа: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`, опционально `Retry-After`.
- Тесты: `pytest` для ядра стратегий и интеграционные для маршрутов (с Redis и без).
- Качество кода: `pre-commit`, `ruff`, `black`, статический анализ `mypy`.
- CI: GitHub Actions (Python 3.13), кэш зависимостей, запуск тестов и линтеров.
- Наблюдаемость: структурированный логгер, метрики Prometheus (`429` счётчики, latency, по namespace).

Средняя перспектива (3–6 недель)
- Распределённые лимиты: поддержка Redis Cluster/Replica, атомарность через Lua‑скрипты.
- Глобальные квоты: per‑tenant/per‑plan, конфигурация для нескольких тарифов.
- Админ‑эндпоинты: просмотр счётчиков, сброс namespace/клиента, диагностика.
- Интеграция: совместимость с API‑gateway/Nginx (X‑Forwarded‑For), trust‑proxy настройки.
- Тонкая настройка идентификации: приоритет user_id → token → header → IP.
- Бэк‑офф: мягкое замедление перед жёстким 429, адаптивные лимиты.

Дальняя перспектива (6+ недель)
- Мульти‑регион: стратегия согласования лимитов, устойчивость к сетевым сбоям.
- Политики: динамические правила (RBAC/ABAC), контекстные лимиты по маршрутам и ролям.
- Аналитика: экспорт событий в TSDB (например, ClickHouse), дешборды.
- Защита: safelist/denylist клиентов, детекция аномалий/атак (бурсты, брутфорс).
- Потоки: лимитирование WebSocket/стриминговых эндпоинтов.

Технические заметки
- Ключи Redis: `{namespace}:{client}:{window_start}` + TTL, атомарные инкременты.
- Ошибки: единый JSON‑формат для 429, включать лимит/остаток/время сброса/причину.
- Логирование: корреляция `request_id`, сбор по namespace/клиенту для анализа.
- Конфигурация: хранить лимиты в pydantic‑settings, валидировать значения.